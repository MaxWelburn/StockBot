<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stock Bias Trader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1020;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .container {
      max-width: 1100px;
      width: 100%;
      background: #141a33;
      border-radius: 16px;
      padding: 20px 24px 28px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.4);
    }
    h1 {
      margin-top: 0;
      margin-bottom: 0.25rem;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #8f96c7;
      margin-bottom: 1.25rem;
    }
    form {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 1rem;
    }
    label {
      font-size: 0.9rem;
    }
    input[type="text"] {
      flex: 1 1 140px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid #303656;
      background: #0e1430;
      color: #fff;
      outline: none;
    }
    input[type="text"]::placeholder {
      color: #59608d;
    }
    button {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: #4f46e5;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.05s ease, background 0.15s ease;
      box-shadow: 0 8px 20px rgba(79, 70, 229, 0.45);
      min-width: 120px;
    }
    button:disabled {
      background: #30345f;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(79, 70, 229, 0.6);
    }
    .status {
      font-size: 0.85rem;
      color: #a5acd9;
      min-height: 1.25em;
      margin-bottom: 0.5rem;
    }
    .progress-wrapper {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: #1c2340;
      overflow: hidden;
      margin-bottom: 0.35rem;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
      transition: width 0.08s linear;
    }
    .progress-text {
      font-size: 0.8rem;
      color: #8f96c7;
      margin-bottom: 0.75rem;
    }
    #chart {
      max-height: 380px;
    }
    .card-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 14px;
    }
    .card {
      flex: 1 1 220px;
      background: #10162c;
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid #272f4e;
      font-size: 0.86rem;
    }
    .card-title {
      font-size: 0.8rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #8f96c7;
      margin-bottom: 4px;
    }
    .card-main {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .card-sub {
      font-size: 0.8rem;
      color: #a5acd9;
    }
    .error {
      color: #f97373;
    }

    /* Layout: sidebar + main */
    .layout {
      display: flex;
      gap: 18px;
      margin-top: 14px;
    }
    .sidebar {
      width: 220px;
      min-width: 180px;
      background: #10162c;
      border-radius: 12px;
      border: 1px solid #272f4e;
      padding: 10px 10px 12px;
      display: flex;
      flex-direction: column;
      max-height: 520px;
    }
    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .sidebar-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #8f96c7;
    }
    .saved-clear-btn {
      font-size: 0.75rem;
      padding: 4px 10px;
      min-width: 0;
      background: #1f2937;
      box-shadow: none;
    }
    .saved-clear-btn:hover {
      box-shadow: none;
      transform: translateY(-1px);
      background: #374151;
    }
    .saved-empty {
      font-size: 0.8rem;
      color: #9ca3af;
      padding: 4px 2px;
    }
    .saved-scroll {
      overflow-y: auto;
      padding-right: 2px;
    }
    .saved-btn {
      width: 100%;
      text-align: left;
      border-radius: 10px;
      border: 1px solid transparent;
      background: #0f172a;
      padding: 6px 8px;
      margin-bottom: 6px;
      cursor: pointer;
      box-shadow: none;
      min-width: 0;
    }
    .saved-btn:hover {
      background: #111827;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.4);
      transform: translateY(0);
    }
    .saved-btn-main {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 2px;
    }
    .saved-symbol {
      font-weight: 600;
      font-size: 0.9rem;
    }
    .saved-profit-positive {
      color: #4ade80;
      font-size: 0.8rem;
    }
    .saved-profit-negative {
      color: #f97373;
      font-size: 0.8rem;
    }
    .saved-sub {
      font-size: 0.78rem;
      color: #9ca3af;
    }

    .main-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    @media (max-width: 768px) {
      .layout {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Stock Bias Trader</h1>
    <div class="subtitle">
      Enter a symbol or company name, fetch daily prices, optimize thresholds, and see the result &amp; chart.
    </div>

    <form id="symbol-form">
      <label for="symbol-input">Symbol / name:</label>
      <input id="symbol-input" type="text" placeholder="e.g. NVDA or Apple" required />
      <button type="submit" id="run-button">Run</button>
    </form>

    <div id="status" class="status"></div>

    <div class="progress-wrapper">
      <div id="progress-bar" class="progress-bar"></div>
    </div>
    <div id="progress-text" class="progress-text">Idle</div>

    <div class="layout">
      <!-- LEFT: saved symbols -->
      <aside class="sidebar">
        <div class="sidebar-header">
          <div class="sidebar-title">Saved symbols</div>
          <button type="button" class="saved-clear-btn" id="clear-saved">Clear</button>
        </div>
        <div class="saved-scroll" id="saved-list"></div>
      </aside>

      <!-- RIGHT: chart + cards -->
      <section class="main-panel">
        <canvas id="chart"></canvas>

        <div class="card-row">
          <div class="card">
            <div class="card-title">Recommendation</div>
            <div class="card-main" id="decision-text">–</div>
            <div class="card-sub" id="decision-extra"></div>
          </div>
          <div class="card">
            <div class="card-title">Best Thresholds</div>
            <div class="card-main" id="thresholds-text">–</div>
            <div class="card-sub" id="thresholds-extra"></div>
          </div>
          <div class="card">
            <div class="card-title">Simulation Result</div>
            <div class="card-main" id="profit-text">–</div>
            <div class="card-sub" id="profit-extra"></div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const API_KEY = "BT8UUAJIJ09B1IQF";
    const START_WALLET = 4000.0;
    const MAX_LOOKBACK_DAYS = 30;

    const STORAGE_KEY = "biasTraderSavedV1";        // thresholds/results
    const PRICE_CACHE_KEY = "biasTraderPriceV1";    // price data
    const NAME_MAP_KEY = "biasTraderNameMapV1";     // company name -> symbol

    // Built-in company name mapping for common names (can add more)
    const BUILTIN_NAME_MAP = {
      "apple": "AAPL",
      "apple inc": "AAPL",
      "microsoft": "MSFT",
      "microsoft corp": "MSFT",
      "meta": "META",
      "facebook": "META",
      "google": "GOOGL",
      "alphabet": "GOOGL",
      "amazon": "AMZN",
      "nvidia": "NVDA",
      "tesla": "TSLA",
      "netflix": "NFLX",
      "adobe": "ADBE",
      "adobe inc": "ADBE"
    };

    const form = document.getElementById("symbol-form");
    const input = document.getElementById("symbol-input");
    const runButton = document.getElementById("run-button");
    const statusEl = document.getElementById("status");
    const progressBar = document.getElementById("progress-bar");
    const progressText = document.getElementById("progress-text");
    const savedList = document.getElementById("saved-list");
    const clearSavedBtn = document.getElementById("clear-saved");

    const decisionText = document.getElementById("decision-text");
    const decisionExtra = document.getElementById("decision-extra");
    const thresholdsText = document.getElementById("thresholds-text");
    const thresholdsExtra = document.getElementById("thresholds-extra");
    const profitText = document.getElementById("profit-text");
    const profitExtra = document.getElementById("profit-extra");

    const chartCanvas = document.getElementById("chart");
    let priceChart = null;

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg || "";
      statusEl.className = "status" + (isError ? " error" : "");
    }

    function setProgress(percent, label) {
      const p = Math.max(0, Math.min(100, percent));
      progressBar.style.width = p + "%";
      progressText.textContent = label || `Progress: ${p}%`;
    }

    function clampMinMax(value, minVal, maxVal) {
      return Math.max(minVal, Math.min(value, maxVal));
    }

    function todayISO() {
      return new Date().toISOString().slice(0, 10);
    }

    function normalizeName(str) {
      return str.trim().toLowerCase().replace(/[.,]/g, "");
    }

    function loadSaved() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return {};
        return JSON.parse(raw);
      } catch {
        return {};
      }
    }

    function loadPriceCache() {
      try {
        const raw = localStorage.getItem(PRICE_CACHE_KEY);
        if (!raw) return {};
        return JSON.parse(raw);
      } catch {
        return {};
      }
    }

    function loadNameMap() {
      try {
        const raw = localStorage.getItem(NAME_MAP_KEY);
        if (!raw) return {};
        return JSON.parse(raw);
      } catch {
        return {};
      }
    }

    function saveNameMapEntry(name, symbol) {
      const norm = normalizeName(name);
      const map = loadNameMap();
      map[norm] = symbol.toUpperCase();
      localStorage.setItem(NAME_MAP_KEY, JSON.stringify(map));
    }

    function getCachedPricesIfFresh(symbol) {
      const cache = loadPriceCache();
      const sym = symbol.toUpperCase();
      const entry = cache[sym];
      if (!entry) return null;
      if (entry.fetch_date === todayISO()) {
        return { dates: entry.dates, prices: entry.prices };
      }
      return null;
    }

    function savePriceCache(symbol, dates, prices) {
      const cache = loadPriceCache();
      const sym = symbol.toUpperCase();
      cache[sym] = {
        fetch_date: todayISO(),
        dates,
        prices
      };
      localStorage.setItem(PRICE_CACHE_KEY, JSON.stringify(cache));
    }

    function saveBestResult(symbol, result) {
      const sym = symbol.toUpperCase();
      const saved = loadSaved();
      saved[sym] = {
        symbol: sym,
        sell_pct_thresh: result.sell_pct_thresh,
        buy_pct_thresh: result.buy_pct_thresh,
        profit: result.profit,
        final_value: result.final_value,
        last_price: result.last_price,
        last_updated: new Date().toISOString()
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
      renderSavedList();
    }

    function renderSavedList() {
      const saved = loadSaved();
      let symbols = Object.keys(saved);

      if (!symbols.length) {
        savedList.innerHTML =
          '<div class="saved-empty">No saved symbols yet. Run one to add it.</div>';
        return;
      }

      // sort alphabetically
      symbols.sort();
      // pin ADBE to top if present
      const adobeIdx = symbols.indexOf("ADBE");
      if (adobeIdx > 0) {
        symbols.splice(adobeIdx, 1);
        symbols.unshift("ADBE");
      }

      let html = "";
      for (const sym of symbols) {
        const item = saved[sym];
        const profitClass =
          item.profit >= 0 ? "saved-profit-positive" : "saved-profit-negative";
        const profitText =
          (item.profit >= 0 ? "+" : "") + item.profit.toFixed(2);
        html += `
          <button type="button" class="saved-btn" data-symbol="${sym}">
            <div class="saved-btn-main">
              <span class="saved-symbol">${sym}</span>
              <span class="${profitClass}">${profitText}</span>
            </div>
            <div class="saved-sub">
              Sell &gt; ${item.sell_pct_thresh.toFixed(
                1
              )}%, Buy drop &gt; ${item.buy_pct_thresh.toFixed(
          1
        )}% · $${item.last_price.toFixed(2)}
            </div>
          </button>
        `;
      }
      savedList.innerHTML = html;
    }

    // Resolve freeform input (symbol or company name) to a stock symbol
    async function resolveSymbol(inputStr) {
      const raw = inputStr.trim();
      if (!raw) throw new Error("Please enter a symbol or company name.");

      const upper = raw.toUpperCase();
      // If it already looks like a symbol (A–Z + optional dot, 1–5 chars, no spaces)
      if (/^[A-Z.]{1,5}$/.test(upper) && !raw.includes(" ")) {
        return { symbol: upper, source: "direct" };
      }

      const norm = normalizeName(raw);
      const nameMap = loadNameMap();

      if (nameMap[norm]) {
        return { symbol: nameMap[norm], source: "cached-name" };
      }

      if (BUILTIN_NAME_MAP[norm]) {
        const sym = BUILTIN_NAME_MAP[norm];
        saveNameMapEntry(norm, sym);
        return { symbol: sym, source: "builtin-name" };
      }

      // Fallback: AlphaVantage SYMBOL_SEARCH (one-time per new name)
      const url = `https://www.alphavantage.co/query?function=SYMBOL_SEARCH&keywords=${encodeURIComponent(
        raw
      )}&apikey=${encodeURIComponent(API_KEY)}`;

      const resp = await fetch(url);
      const data = await resp.json();

      if (!data || !data.bestMatches || !data.bestMatches.length) {
        console.log("SYMBOL_SEARCH response:", data);
        throw new Error("Could not find a matching stock symbol for that name.");
      }

      const best = data.bestMatches[0];
      const sym = (best["1. symbol"] || "").toUpperCase();
      if (!sym) {
        throw new Error("Could not parse symbol from search result.");
      }

      saveNameMapEntry(norm, sym);
      return { symbol: sym, source: "api-search" };
    }

    // Fetch stock data (TIME_SERIES_DAILY) – assumes we already decided to call the API
    async function fetchStockDataFromApi(symbol) {
      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${encodeURIComponent(
        symbol
      )}&outputsize=compact&apikey=${encodeURIComponent(API_KEY)}`;

      const resp = await fetch(url);
      const data = await resp.json();

      if (!data || !data["Time Series (Daily)"]) {
        console.log("AlphaVantage response:", data);
        if (data && (data["Note"] || data["Information"])) {
          throw new Error(data["Note"] || data["Information"]);
        }
        if (data && data["Error Message"]) {
          throw new Error("API error: " + data["Error Message"]);
        }
        throw new Error("Unexpected API response.");
      }

      const series = data["Time Series (Daily)"];
      const entries = Object.entries(series).map(([dateStr, daily]) => {
        const price = parseFloat(daily["4. close"]);
        return { dateStr, price };
      });

      entries.sort((a, b) => (a.dateStr < b.dateStr ? -1 : 1));

      const lastEntries = entries.slice(Math.max(0, entries.length - 260));
      const dates = lastEntries.map((e) => e.dateStr);
      const prices = lastEntries.map((e) => e.price);

      if (!prices.length) {
        throw new Error("No prices returned for symbol " + symbol);
      }

      return { dates, prices };
    }

    // High-level: get stock data, using per-day cache to save API calls
    async function getStockData(symbol) {
      const sym = symbol.toUpperCase();

      const cached = getCachedPricesIfFresh(sym);
      if (cached) {
        setStatus(`Using cached prices for ${sym} (fetched earlier today).`);
        return cached;
      }

      setStatus(`Fetching stock data for ${sym}...`);
      const { dates, prices } = await fetchStockDataFromApi(sym);
      savePriceCache(sym, dates, prices);
      return { dates, prices };
    }

    function biasedTrader(prices, startWallet, sellPctThresh, buyPctThresh, maxLookbackDays) {
      let wallet = startWallet;
      let shares = [];
      let lastDecision = "HOLD";
      let lastAmount = 0;
      let lastActionPrice = 0.0;

      for (let i = 1; i < prices.length; i++) {
        const price = prices[i];

        lastDecision = "HOLD";
        lastAmount = 0;
        lastActionPrice = 0.0;

        for (let idx = shares.length - 1; idx >= 0; idx--) {
          const [buyPrice, amount] = shares[idx];
          const profitPct = buyPrice !== 0 ? ((price - buyPrice) / buyPrice) * 100 : 0;

          if (buyPrice < price && profitPct > sellPctThresh) {
            wallet += amount * price;
            shares.splice(idx, 1);
            lastAmount += amount;
            lastActionPrice = price;
            lastDecision = "SELL";
          }
        }

        if (wallet > price) {
          let highestPercent = 0.0;
          const maxBack = clampMinMax(maxLookbackDays + 1, 1, i);

          for (let x = 1; x < maxBack; x++) {
            const prevPrice = prices[i - x];
            if (price < prevPrice) {
              const dropPct = ((price - prevPrice) / prevPrice) * 100;
              if (dropPct < highestPercent) {
                highestPercent = dropPct;
              }
            }
          }

          if (highestPercent < -buyPctThresh) {
            let amount = 0;
            for (let step = 1; step <= Math.floor(Math.abs(highestPercent)); step++) {
              if (wallet > price) {
                wallet -= price;
                amount += 1;
              }
            }

            if (amount > 0) {
              shares.push([price, amount]);
              lastAmount = amount;
              lastActionPrice = price;
              lastDecision = "BUY";
            }
          }
        }
      }

      const finalPrice = prices[prices.length - 1];
      const totalShares = shares.reduce((acc, [, amt]) => acc + amt, 0);
      const finalValue = wallet + totalShares * finalPrice;
      const profit = finalValue - startWallet;

      return {
        final_wallet: wallet,
        final_shares: shares,
        final_value: finalValue,
        profit,
        sell_pct_thresh: sellPctThresh,
        buy_pct_thresh: buyPctThresh,
        last_decision: lastDecision,
        last_amount: lastAmount,
        last_action_price: lastActionPrice,
        last_price: finalPrice
      };
    }

    async function gridSearchThresholdsWithProgress(prices, startWallet, onProgress) {
      const sellValues = [];
      const buyValues = [];
      for (let i = 1; i <= 200; i++) {
        const v = i / 10.0;
        sellValues.push(v);
        buyValues.push(v);
      }

      const totalIters = sellValues.length * buyValues.length;
      let count = 0;
      let lastPercentShown = -1;

      let bestProfit = -Infinity;
      let bestResult = null;

      for (let si = 0; si < sellValues.length; si++) {
        const sellThresh = sellValues[si];
        for (let bi = 0; bi < buyValues.length; bi++) {
          const buyThresh = buyValues[bi];

          count++;
          const percent = Math.floor((count * 100) / totalIters);
          if (onProgress && percent !== lastPercentShown) {
            lastPercentShown = percent;
            onProgress(percent);
          }

          const res = biasedTrader(
            prices,
            startWallet,
            sellThresh,
            buyThresh,
            MAX_LOOKBACK_DAYS
          );

          if (res.profit > bestProfit) {
            bestProfit = res.profit;
            bestResult = res;
          }

          if (count % 400 === 0) {
            await new Promise((resolve) => requestAnimationFrame(resolve));
          }
        }
      }

      if (onProgress) onProgress(100);
      return bestResult;
    }

    function updateChart(symbol, dates, prices) {
      if (priceChart) {
        priceChart.destroy();
      }
      priceChart = new Chart(chartCanvas.getContext("2d"), {
        type: "line",
        data: {
          labels: dates,
          datasets: [
            {
              label: `${symbol.toUpperCase()} Close Price`,
              data: prices,
              borderWidth: 1.5,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: {
                maxTicksLimit: 8
              }
            },
            y: {
              beginAtZero: false
            }
          },
          plugins: {
            legend: {
              labels: { color: "#e5e7eb" }
            }
          }
        }
      });
    }

    async function runForInput(inputValue, { forceReoptimize = false } = {}) {
      const raw = inputValue.trim();
      if (!raw) return;

      runButton.disabled = true;
      setStatus("Resolving symbol...");
      setProgress(0, "Resolving symbol...");
      decisionText.textContent = "–";
      decisionExtra.textContent = "";
      thresholdsText.textContent = "–";
      thresholdsExtra.textContent = "";
      profitText.textContent = "–";
      profitExtra.textContent = "";

      try {
        const { symbol, source } = await resolveSymbol(raw);
        input.value = symbol; // show resolved symbol
        let sourceLabel = "";
        if (source === "direct") sourceLabel = " (direct symbol)";
        else if (source === "builtin-name") sourceLabel = " (from built-in name)";
        else if (source === "cached-name") sourceLabel = " (cached name ↦ symbol)";
        else if (source === "api-search") sourceLabel = " (via name search)";

        setStatus(`Using symbol ${symbol}${sourceLabel}.`);
        setProgress(5, "Checking cached prices...");

        const { dates, prices } = await getStockData(symbol);
        updateChart(symbol, dates, prices);

        const saved = loadSaved()[symbol.toUpperCase()];
        let bestResult;

        if (saved && !forceReoptimize) {
          setProgress(20, "Using cached thresholds...");
          bestResult = biasedTrader(
            prices,
            START_WALLET,
            saved.sell_pct_thresh,
            saved.buy_pct_thresh,
            MAX_LOOKBACK_DAYS
          );
          bestResult.sell_pct_thresh = saved.sell_pct_thresh;
          bestResult.buy_pct_thresh = saved.buy_pct_thresh;
          setProgress(100, "Using cached thresholds");
        } else {
          setProgress(10, "Optimizing thresholds...");
          bestResult = await gridSearchThresholdsWithProgress(
            prices,
            START_WALLET,
            (p) => setProgress(p, `Grid search: ${p}%`)
          );
        }

        if (!bestResult) throw new Error("No result from grid search.");

        const decision = bestResult.last_decision;
        const amount = bestResult.last_amount;
        const actionPrice = bestResult.last_action_price;

        let decisionMain;
        if (decision === "BUY" && amount > 0) {
          decisionMain = `BUY ${amount} shares`;
        } else if (decision === "SELL" && amount > 0) {
          decisionMain = `SELL ${amount} shares`;
        } else {
          decisionMain = "HOLD";
        }
        decisionText.textContent = `${symbol}: ${decisionMain}`;
        if (amount > 0 && actionPrice > 0) {
          decisionExtra.textContent = `Last action at $${actionPrice.toFixed(
            2
          )} | Last price $${bestResult.last_price.toFixed(2)}`;
        } else {
          decisionExtra.textContent = `Last price $${bestResult.last_price.toFixed(2)}`;
        }

        thresholdsText.textContent = `Sell > ${bestResult.sell_pct_thresh.toFixed(
          1
        )}%, Buy drop > ${bestResult.buy_pct_thresh.toFixed(1)}%`;
        thresholdsExtra.textContent = `Lookback up to ${MAX_LOOKBACK_DAYS} days | Start wallet $${START_WALLET.toFixed(
          2
        )}`;

        const profit = bestResult.profit;
        const finalValue = bestResult.final_value;
        profitText.textContent =
          (profit >= 0 ? "+" : "") + profit.toFixed(2) + " USD";
        profitExtra.textContent = `Final value: $${finalValue.toFixed(
          2
        )} (wallet + holdings)`;

        saveBestResult(symbol, bestResult);

        setStatus(saved && !forceReoptimize
          ? "Done (cached thresholds, cached prices if available)."
          : "Done.");
      } catch (err) {
        console.error(err);
        setStatus(String(err), true);
        setProgress(0, "Idle");
      } finally {
        runButton.disabled = false;
      }
    }

    form.addEventListener("submit", (e) => {
      e.preventDefault();
      runForInput(input.value);
    });

    savedList.addEventListener("click", (e) => {
      const btn = e.target.closest(".saved-btn");
      if (!btn) return;
      const sym = btn.dataset.symbol;
      input.value = sym;
      runForInput(sym); // will use cached thresholds & prices if present
    });

    clearSavedBtn.addEventListener("click", () => {
      localStorage.removeItem(STORAGE_KEY);
      renderSavedList();
    });

    renderSavedList();
    input.focus();
  </script>
</body>
</html>
